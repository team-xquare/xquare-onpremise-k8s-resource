apiVersion: apps/v1
kind: Deployment
metadata:
  name: test-app
  namespace: {{ .Release.Namespace }}
  labels:
    app: test-app
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      app: test-app
  template:
    metadata:
      labels:
        app: test-app
      annotations:
        # OpenTelemetry Sidecar 주입
        sidecar.opentelemetry.io/inject: "monitoring/otel-sidecar"

        # Python Auto-Instrumentation 주입
        instrumentation.opentelemetry.io/inject-python: "true"

        # 또는 특정 Instrumentation 지정
        # instrumentation.opentelemetry.io/inject-python: "test-instrumentation"
    spec:
      containers:
      - name: app
        image: python:3.11-slim
        command:
        - /bin/sh
        - -c
        - |
          pip install flask requests --quiet
          cat > /app.py << 'EOF'
          from flask import Flask, request
          import requests
          import random
          import time
          import logging

          app = Flask(__name__)
          logging.basicConfig(level=logging.INFO)
          logger = logging.getLogger(__name__)

          @app.route('/')
          def index():
              logger.info("Index endpoint called")
              return {
                  "message": "Hello from test-app!",
                  "tenant_id": "{{ .Values.tenantId }}",
                  "namespace": "{{ .Release.Namespace }}"
              }

          @app.route('/api/users')
          def users():
              # 외부 API 호출 시뮬레이션
              logger.info("Users endpoint called")
              time.sleep(random.uniform(0.01, 0.1))
              return {
                  "users": [
                      {"id": 1, "name": "Alice"},
                      {"id": 2, "name": "Bob"}
                  ]
              }

          @app.route('/api/orders')
          def orders():
              logger.info("Orders endpoint called")

              # users API 호출 (분산 트레이싱 테스트)
              try:
                  response = requests.get('http://localhost:8080/api/users', timeout=1)
                  users = response.json()
              except Exception as e:
                  logger.error(f"Failed to fetch users: {e}")
                  users = []

              time.sleep(random.uniform(0.05, 0.2))
              return {
                  "orders": [
                      {"id": 1, "user_id": 1, "amount": 100},
                      {"id": 2, "user_id": 2, "amount": 200}
                  ],
                  "users": users
              }

          @app.route('/api/error')
          def error():
              logger.error("Error endpoint called - simulating error")
              raise Exception("Simulated error for testing")

          @app.route('/health')
          def health():
              return {"status": "healthy"}

          if __name__ == '__main__':
              app.run(host='0.0.0.0', port=8080)
          EOF

          python /app.py
        ports:
        - containerPort: 8080
          name: http
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
